
CCEffect %{
    techniques:
    - passes:
        - vert: vs
          frag: fs
          blendState:
              targets:
              - blend: true
          rasterizerState:
              cullMode: none
          properties:
              texture: { value: white }
              u_width: { value: 5. }
              u_shift: { value: 5. }
}%

CCProgram vs %{
    precision highp float;

    #include <cc-global>
    #include <cc-local>

    in vec3 a_position;
    in vec4 a_color;
    out vec4 v_color;

    in vec2 a_uv0;
    out vec2 v_uv0;
    
    void main() {
        vec4 pos = vec4(a_position, 1);
        pos = cc_matViewProj * pos;
        v_uv0 = a_uv0;
        // v_uv0.y = 1.0 - v_uv0.y;  // flip y

        v_color = a_color;
        gl_Position = pos;
    }
}%

CCProgram fs %{
    precision highp float;

    #include <cc-global>
    #include <cc-local>
    
    in vec4 v_color;
    in vec2 v_uv0;

    uniform sampler2D texture;
    uniform sampler2D tex2;
    uniform UARGS {
        float u_width;
        float u_shift;
    };

    // 2D Random
    float random (in vec2 st) {
        return fract(sin(dot(st.xy,
                            vec2(12.9898,78.233)))
                    * 43758.5453123);
    }

    // 2D Noise based on Morgan McGuire @morgan3d
    // https://www.shadertoy.com/view/4dS3Wd
    // Perlin Noise
    float noise (in vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);

        // Four corners in 2D of a tile
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));

        // Smooth Interpolation

        // Cubic Hermine Curve.  Same as SmoothStep()
        vec2 u = f*f*(3.0-2.0*f);
        // u = smoothstep(0.,1.,f);

        // Mix 4 coorners percentages
        return mix(a, b, u.x) +
                (c - a)* u.y * (1.0 - u.x) +
                (d - b) * u.x * u.y;
    }

    void main()
    {
        float blur = 4. / 720.;
        vec4 col = texture2D(tex2, v_uv0);

#if SHOW_SDF
        float threshold = 0.98;      // todo: control width
        col.a = smoothstep(threshold-blur, threshold, col.a);
#elif SQUIGGLE
        vec2 uv = v_uv0.xy;
        float seed = mod(floor(cc_time.x * 3.), 5.);
        float D = (col.a - 1.0) * 360.;

        float grid = 20.;       // 位移的细度
        float shift = u_shift;//2.;      // 位移幅度
        shift *= noise(grid * uv + seed);
        // D = D + shift * noise(grid * uv + seed);

        float width = u_width;//5.;
        // float mask = smoothstep(-width-1.+shift, -width+shift, D) - smoothstep(width+shift, width+1.+shift, D);
        // float mask = smoothstep()
        float mask = smoothstep(width+1., width, abs(D) - shift);
        col = vec4(mask);
#elif BLOOM
        col = smoothstep(0.92, 0.98, col);
#endif

        gl_FragColor = vec4(col);
    }
}%
